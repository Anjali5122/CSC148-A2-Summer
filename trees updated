from __future__ import annotations
from typing import Optional, List, Tuple, Dict


class OutOfBoundsError(Exception):
    pass


class Tree:
    def __contains__(self, name: str) -> bool:
        """ Return True if a player named <name> is stored in this tree.

        Runtime: O(n)
        """
        raise NotImplementedError

    def contains_point(self, point: Tuple[int, int]) -> bool:
        """ Return True if a player at location <point> is stored in this tree.

        Runtime: O(log(n))
        """
        raise NotImplementedError

    def insert(self, name: str, point: Tuple[int, int]) -> None:
        """Insert a player named <name> into this tree at point <point>.

        Raise an OutOfBoundsError if <point> is out of bounds.

        Runtime: O(log(n))
        """

    def remove(self, name: str) -> None:
        """ Remove information about a player named <name> from this tree.

        Runtime: O(n)
        """
        raise NotImplementedError

    def remove_point(self, point: Tuple[int, int]) -> None:
        """ Remove information about a player at point <point> from this tree.

        Runtime: O(log(n))
        """
        raise NotImplementedError

    def move(self, name: str, direction: str, steps: int) -> Optional[
        Tuple[int, int]]:
        """ Return the new location of the player named <name> after moving it
        in the given <direction> by <steps> steps.

        Raise an OutOfBoundsError if this would move the player named
        <name> out of bounds (before moving the player).

        Runtime: O(n)

        === precondition ===
        direction in ['N', 'S', 'E', 'W']
        """
        raise NotImplementedError

    def move_point(self, point: Tuple[int, int], direction: str, steps: int) ->\
            Optional[Tuple[int, int]]:
        """ Return the new location of the player at point <point> after moving it
        in the given <direction> by <steps> steps.

        Raise an OutOfBoundsError if this would move the player at point
        <point> out of bounds (before moving the player).

        Moving a point may require the tree to be reorganized. This method should do
        the minimum amount of tree reorganization possible to move the given point properly.

        Runtime: O(log(n))

        === precondition ===
        direction in ['N', 'S', 'E', 'W']

        """
        raise NotImplementedError

    def names_in_range(self, point: Tuple[int, int], direction: str,
                       distance: int) -> List[str]:
        """ Return a list of names of players whose location is in the <direction>
        relative to <point> and whose location is within <distance> along both the x and y axis.

        For example: names_in_range((100, 100), 'SE', 10) should return the names of all
        the players south east of (100, 100) and within 10 steps in either direction.
        In other words, find all players whose location is in the box with corners at:
        (100, 100) (110, 100) (100, 110) (110, 110)

        Runtime: faster than O(n) when distance is small

        === precondition ===
        direction in ['NE', 'SE', 'NE', 'SW']
        """
        raise NotImplementedError

    def size(self) -> int:
        """ Return the number of nodes in <self>

        Runtime: O(n)
        """
        raise NotImplementedError

    def height(self) -> int:
        """ Return the height of <self>

        Runtime: O(n)
        """
        raise NotImplementedError

    def depth(self, tree: Tree) -> Optional[int]:
        """ Return the depth of the subtree <tree> relative to <self>.
        Return None if <tree> is not a descendant of <self>

        Runtime: O(log(n))
        """

    def is_leaf(self) -> bool:
        """ Return True if <self> has no children

        Runtime: O(1)
        """
        raise NotImplementedError

    def is_empty(self) -> bool:
        """ Return True if <self> does not store any information about the location
        of any players.

        Runtime: O(1)
        """
        raise NotImplementedError


class QuadTree(Tree):
    """ A QuadTree instance.
    === Representation Invariants ===
    - only leaves can have non-None _name attributes
    - every leaf must have a non-None _name unless it has no parents
    - only leaves can have non-None _point attributes
    - every leaf node must have a non-None _point attribute unless it also has
    no parents
    - every non-None _point attribute must contain only positive integers or
    zero
    - every _centre attribute must contain only positive integers or zero
    - every _centre attribute describes a point that is the exact centre of the
     rectangle (if the exact centre is not an integer, the values in _centre
     should be rounded down to the nearest integer).
    - if _point is not None, then _point[0] <= 2*_centre[0]
    - if _point is not None, then _point[1] <= 2*_centre[1]
    - if d._point is not None for some descendant d of p, then:
    - d must be in the _nw or _sw subtrees if d._point[0] <= p._centre[0] and in
     one of the other subtrees otherwise.
    - d must be in the _nw or _ne subtrees if d._point[1] <= p._centre[1] and in
     one of the other subtrees otherwise.
    """

    _centre: Tuple[int, int]
    _name: Optional[str]
    _point: Optional[Tuple[int, int]]
    _ne: Optional[QuadTree]
    _nw: Optional[QuadTree]
    _se: Optional[QuadTree]
    _sw: Optional[QuadTree]

    def __init__(self, centre: Tuple[int, int]) -> None:
        """Initialize a new QuadTree instance

        Runtime: O(1)
        """
        self._centre = centre
        self._name = None
        self._point = None
        self._ne = None
        self._nw = None
        self._se = None
        self._sw = None

    def __contains__(self, name: str) -> bool:
        """ Return True if a player named <name> is stored in this tree.

        Runtime: O(n)
        """
        if self.is_leaf():
            if self._name == name:
                return True
            return False
        else:
            if self._nw is not None:
                north_w = name in self._nw
                if north_w:
                    return True
            if self._ne is not None:
                north_e = name in self._ne
                if north_e:
                    return True
            if self._sw is not None:
                south_w = name in self._sw
                if south_w:
                    return True
            if self._se is not None:
                south_e = name in self._se
                if south_e:
                    return True
        return False

    def contains_point(self, point: Tuple[int, int]) -> bool:
        """ Return True if a player at location <point> is stored in this tree.

        Runtime: O(log(n))
        """
        if self.is_empty():
            return False
        if self.is_leaf():
            if self._point == point:
                return True
            return False
        elif point[0] <= self._centre[0] and point[1] <= self._centre[1]:
            if self._nw is None:
                return False
            if self._nw.contains_point(point):
                return True
        elif point[0] <= self._centre[0] and point[1] > self._centre[1]:
            if self._sw is None:
                return False
            if self._sw.contains_point(point):
                return True
        elif point[0] > self._centre[0] and point[1] <= self._centre[1]:
            if self._ne is None:
                return False
            if self._ne.contains_point(point):
                return True
        elif point[0] > self._centre[0] and point[1] > self._centre[1]:
            if self._se is None:
                return False
            elif self._se.contains_point(point):
                return True
        return False

    def insert(self, name: str, point: Tuple[int, int]) -> None:
        """Insert a player named <name> into this tree at point <point>.

        Raise an OutOfBoundsError if <point> is out of bounds.

        Runtime: O(log(n))
        """
        if not (point[0] <= 2*self._centre[0] and point[1]
                <= 2*self._centre[1]):
            raise OutOfBoundsError
        if self.contains_point(point):
            raise OutOfBoundsError
        if self.is_empty():
            self._name = name
            self._point = point
        else:
            top_corner = (0, 0)
            bot_corner = (2*self._centre[0], 2*self._centre[1])
            self._insert_helper(top_corner, bot_corner, name, point)

    def _insert_helper(self, top, bottom, name, point):
        if self._name is None:
            if point[0] <= self._centre[0] and point[1] <= self._centre[1]:
                if self._nw is None:
                    nw_tree = QuadTree((int((self._centre[0] + top[0])/2),
                                        int((self._centre[1] + top[1])/2)))
                    nw_tree._name = name
                    nw_tree._point = point
                    self._nw = nw_tree
                else:
                    self._nw._insert_helper(top, self._centre, name, point)
            elif point[0] <= self._centre[0] and point[1] > self._centre[1]:
                if self._sw is None:
                    corner_top = (top[0], self._centre[1])
                    corner_bottom = (self._centre[0], bottom[1])
                    sw_tree = QuadTree((int((corner_top[0] + corner_bottom[0])/2),
                                    int((corner_top[1] + corner_bottom[1])/2)))
                    sw_tree._name = name
                    sw_tree._point = point
                    self._sw = sw_tree
                else:
                    corner_top = (top[0], self._centre[1])
                    corner_bottom = (self._centre[0], bottom[1])
                    self._sw._insert_helper(corner_top, corner_bottom, name, point)
            elif point[0] >= self._centre[0] and point[1] <= self._centre[1]:
                if self._ne is None:
                    corner_top = (self._centre[0], top[1])
                    corner_bottom = (bottom[0], self._centre[1])
                    ne_tree = QuadTree(
                        (int((corner_top[0] + corner_bottom[0])/2),
                         int((corner_top[1] + corner_bottom[1])/2))
                        )
                    ne_tree._name = name
                    ne_tree._point = point
                    self._ne = ne_tree
                else:
                    corner_top = (self._centre[0], top[1])
                    corner_bottom = (bottom[0], self._centre[1])
                    self._ne._insert_helper(corner_top, corner_bottom, name, point)
            elif point[0] >= self._centre[0] and point[1] > self._centre[1]:
                if self._se is None:
                    se_tree = QuadTree(
                        (int((self._centre[0] + bottom[0])/2),
                         int((self._centre[1] + bottom[1])/2)))
                    se_tree._name = name
                    se_tree._point = point
                    self._se = se_tree
                else:
                    self._se._insert_helper(self._centre, bottom, name, point)
        else:
            assert self.is_leaf()
            hold_point = self._point
            hold_name = self._name
            self._name, self._point = None, None
            self._insert_helper(top, bottom, hold_name, hold_point)
            self._insert_helper(top, bottom, name, point)

    def remove(self, name: str) -> None:
        """ Remove information about a player named <name> from this tree.

        Runtime: O(n)
        """
        if self._name is not None and self._name == name:
            self._point = None
            self._name = None
        if not self.is_empty():
            self._remove_helper(name)

    def _remove_helper(self, name) -> bool:
        if self.is_empty():
            return False
        if self._nw is not None:
            if self._nw.is_leaf():
                if self._nw._name == name:
                    self._nw = None
                    self._collapse()
                    return True
            else:
                if self._nw._remove_helper(name):
                    self._collapse()
                    return True
        if self._ne is not None:
            if self._ne.is_leaf():
                if self._ne._name == name:
                    self._ne = None
                    self._collapse()
                    return True
            else:
                if self._ne._remove_helper(name):
                    self._collapse()
                    return True
        if self._sw is not None:
            if self._sw.is_leaf():
                if self._sw._name == name:
                    self._sw = None
                    self._collapse()
                    return True
            else:
                if self._sw._remove_helper(name):
                    return True
        if self._se is not None:
            if self._se.is_leaf():
                if self._se._name == name:
                    self._se = None
                    self._collapse()
                    return True
            else:
                if self._se._remove_helper(name):
                    self._collapse()
                    return True

    def _collapse(self) -> None:
        trees = []
        no_promote = []
        if self._nw is not None:
            if self._nw.is_leaf():
                trees.append('nw')
            else:
                no_promote.append('nw')
        if self._ne is not None:
            if self._ne.is_leaf():
                trees.append('ne')
            else:
                no_promote.append('ne')
        if self._sw is not None:
            if self._sw.is_leaf():
                trees.append('sw')
            else:
                no_promote.append('sw')
        if self._se is not None:
            if self._se.is_leaf():
                trees.append('se')
            else:
                no_promote.append('se')
        if len(trees) == 1 and len(no_promote) == 0:
            if trees[0] == 'nw':
                self._name = self._nw._name
                self._point = self._nw._point
                self._nw = None
            elif trees[0] == 'ne':
                self._name = self._ne._name
                self._point = self._ne._point
                self._ne = None
            elif trees[0] == 'sw':
                self._name = self._sw._name
                self._point = self._sw._point
                self._sw = None
            elif trees[0] == 'se':
                self._name = self._se._name
                self._point = self._se._point
                self._se = None

    def remove_point(self, point: Tuple[int, int]) -> None:
        """ Remove information about a player at point <point> from this tree.

        Runtime: O(log(n))
        """
        if not self.contains_point(point):
            return None
        if self.is_leaf():
            # leaf and root
            if self._point[0] == point[0] and self._point[1] == point[1]:
                self._name = None
                self._point = None
        else:
            self._remove_point_helper(point)

    def _remove_point_helper(self, point):
        if point[0] <= self._centre[0] and point[1] <= self._centre[1]:
            if self._nw.is_leaf():
                if self._nw._point == point: # not sure if necessary
                    self._nw = None
                    self._collapse()
            else:
                self._nw._remove_point_helper(point)
                self._collapse()
        elif point[0] <= self._centre[0] and point[1] > self._centre[1]:
            if self._sw.is_leaf():
                if self._sw._point == point:
                    self._sw = None
                    self._collapse()
            else:
                self._sw._remove_point_helper(point)
                self._collapse()
        elif point[0] > self._centre[0] and point[1] <= self._centre[1]:
            if self._ne.is_leaf():
                if self._ne._point == point:
                    self._ne = None
                    self._collapse()
            else:
                self._ne._remove_point_helper(point)
                self._collapse()
        else:
            if self._se.is_leaf():
                if self._se._point == point:
                    self._se = None
                    self._collapse()
            else:
                self._se._remove_point_helper(point)
                self._collapse()

    def move(self, name: str, direction: str, steps: int) -> Optional[
        Tuple[int, int]]:
        """ Return the new location of the player named <name> after moving it
        in the given <direction> by <steps> steps.

        Raise an OutOfBoundsError if this would move the player named
        <name> out of bounds (before moving the player).

        Runtime: O(n)

        === precondition ===
        direction in ['N', 'S', 'E', 'W']
        """
        field = self._centre
        if self.is_leaf() and self._name == name:
            x_cord, y_cord = self._change_coordinates(direction, steps)
            if self.contains_point((x_cord, y_cord)):
                raise OutOfBoundsError
            if 0 <= x_cord <= 2 * field[0] and 0 <= y_cord <= 2 * field[1]:
                if self.contains_point((x_cord, y_cord)):
                    raise OutOfBoundsError
                self._point = (x_cord, y_cord)
            else:
                raise OutOfBoundsError
        else:
            return self._main_move_helper(name, direction, steps)

    def _main_move_helper(self, name, direction, steps):
        field = self._centre
        top = (0, 0)
        bottom = (self._centre[0]*2, self._centre[1]*2)
        tree = self._get_player_byname(top, bottom, name, direction, steps)
        if tree:
            x_cord, y_cord = tree[2]
            if 0 <= x_cord <= 2 * field[0] and 0 <= y_cord <= 2 * field[1]:
                new_point = (x_cord, y_cord)
                if self.contains_point(new_point):
                    raise OutOfBoundsError
                tree[0]._point = new_point
                if not tree[1]:
                    self.remove(tree[0]._name)
                    self.insert(tree[0]._name, new_point)
                    return new_point
                else:
                    return tree[2]
            else:
                raise OutOfBoundsError

    def _get_player_byname(self, top, bot, name, direction, steps) -> \
            Optional[Tuple[QuadTree, bool, Tuple[int, int]]]:
        if self._nw is not None:
            if self._nw.is_leaf() and self._nw._name == name:
                p = self._nw._change_coordinates(direction, steps)
                if top[0] <= p[0] <= self._centre[0] and top[1] <= p[1] <= self._centre[1]:
                    return self._nw, True, p
                else:
                    return self._nw, False, p
            else:
                tree = self._nw._get_player_byname(top, self._centre, name, direction, steps)
                if tree:
                    return tree
        if self._ne is not None:
            if self._ne.is_leaf() and self._ne._name == name:
                p = self._ne._change_coordinates(direction, steps)
                top_c = (self._centre[0], top[1])
                bot_c = (bot[0], self._centre[1])
                if top_c[0] <= p[0] <= bot_c[0] and top_c[1] <= p[1] <= bot_c[1]:
                    return self._ne, True, p
                else:
                    return self._ne, False, p
            else:
                top_c = (self._centre[0], top[1])
                bot_c = (bot[0], self._centre[1])
                tree = self._ne._get_player_byname(top_c, bot_c, name, direction, steps)
                if tree:
                    return tree
        if self._sw is not None:
            if self._sw.is_leaf() and self._sw._name == name:
                p = self._sw._change_coordinates(direction, steps)
                top_c = (top[0], self._centre[1])
                bot_c = (self._centre[0], bot[1])
                if top_c[0] <= p[0] <= bot_c[0] and top_c[1] <= p[1] <= bot_c[1]:
                    return self._sw, True, p
                else:
                    return self._sw, False, p
            else:
                top_c = (top[0], self._centre[1])
                bot_c = (self._centre[0], bot[1])
                tree = self._sw._get_player_byname(top_c, bot_c, name, direction, steps)
                if tree:
                    return tree
        if self._se is not None:
            if self._se.is_leaf() and self._se._name == name:
                p = self._se._change_coordinates(direction, steps)
                if self._centre[0] <= p[0] <= bot[0] and bot[1] >= p[1] >= self._centre[1]:
                    return self._se, True, p
                else:
                    return self._se, False, p
            else:
                tree = self._se._get_player_byname(self._centre, bot, name, direction, steps)
                if tree:
                    return tree

    def _change_coordinates(self, direction, steps) -> Tuple[int, int]:
        x_coord = self._point[0]
        y_coord = self._point[1]
        if direction == 'N':
            y_coord = y_coord - steps
        elif direction == 'E':
            x_coord = x_coord + steps
        elif direction == 'S':
            y_coord = y_coord + steps
        elif direction == 'W':
            x_coord = x_coord - steps

        return x_coord, y_coord


    def move_point(self, point: Tuple[int, int], direction: str, steps: int) ->\
            Optional[Tuple[int, int]]:
        """ Return the new location of the player at point <point> after moving it
        in the given <direction> by <steps> steps.

        Raise an OutOfBoundsError if this would move the player at point
        <point> out of bounds (before moving the player).

        Moving a point may require the tree to be reorganized. This method should do
        the minimum amount of tree reorganization possible to move the given point properly.

        Runtime: O(log(n))

        === precondition ===
        direction in ['N', 'S', 'E', 'W']

        """
        field = self._centre
        if not self.contains_point(point):
            return None
        if self._point == point:
            p = self._change_coordinates(direction, steps)
            if 0 <= p[0] <= 2 * field[0] and 0 <= p[1] <= 2 * field[
                1]:
                if self.contains_point(p):
                    raise OutOfBoundsError
                self._point = p
                return p
            else:
                raise OutOfBoundsError
        else:
            bottom = (self._centre[0] * 2, self._centre[1] * 2)
            tree = self._movepoint_helper((0, 0), bottom, point, direction, steps)
            if tree:
                x_cord, y_cord = tree[2]
                if 0 <= x_cord <= 2 * field[0] and 0 <= y_cord <= 2 * field[
                    1]:
                    new_point = (x_cord, y_cord)
                    if self.contains_point(new_point):
                        raise OutOfBoundsError
                    tree[0]._point = new_point
                    if not tree[1]:
                        self.remove(tree[0]._name)
                        self.insert(tree[0]._name, new_point)
                        return new_point
                    else:
                        return tree[2]
                else:
                    raise OutOfBoundsError

    def _movepoint_helper(self, top, bot, point, direction, steps):
        if point[0] <= self._centre[0] and point[1] <= self._centre[1]:
            if self._nw is not None:
                if self._nw.is_leaf() and self._nw._point == point:
                    p = self._nw._change_coordinates(direction, steps)
                    if top[0] <= p[0] <= self._centre[0] and top[1] <= p[1] <= \
                            self._centre[1]:
                        return self._nw, True, p
                    else:
                        return self._nw, False, p
                else:
                    tree = self._nw._movepoint_helper(top, self._centre, point, direction, steps)
                    if tree:
                        return tree
        elif point[0] >= self._centre[0] and point[1] <= self._centre[1]:
            if self._ne is not None:
                if self._ne.is_leaf() and self._point == point:
                    p = self._ne._change_coordinates(direction, steps)
                    top_c = (self._centre[0], top[1])
                    bot_c = (bot[0], self._centre[1])
                    if top_c[0] <= p[0] <= bot_c[0] and top_c[1] <= p[1] <= bot_c[
                        1]:
                        return self._ne, True, p
                    else:
                        return self._ne, False, p
                else:
                    top_c = (self._centre[0], top[1])
                    bot_c = (bot[0], self._centre[1])
                    tree = self._ne._movepoint_helper(top_c, bot_c, point, direction, steps)
                    if tree:
                        return tree
        elif point[0] <= self._centre[0] and point[1] > self._centre[1]:
            if self._sw is not None:
                if self._sw.is_leaf() and self._sw._point == point:
                    p = self._sw._change_coordinates(direction, steps)
                    top_c = (top[0], self._centre[1])
                    bot_c = (self._centre[0], bot[1])
                    if top_c[0] <= p[0] <= bot_c[0] and top_c[1] <= p[1] <= bot_c[
                        1]:
                        return self._sw, True, p
                    else:
                        return self._sw, False, p
                else:
                    top_c = (top[0], self._centre[1])
                    bot_c = (self._centre[0], bot[1])
                    tree = self._sw._movepoint_helper(top_c, bot_c, point, direction, steps)
                    if tree:
                        return tree
        elif point[0] > self._centre[0] and point[1] > self._centre[1]:
            if self._se is not None:
                if self._se.is_leaf() and self._se._point == point:
                    p = self._se._change_coordinates(direction, steps)
                    if self._centre[0] <= p[0] <= bot[0] and bot[1] >= p[1] >= \
                            self._centre[1]:
                        return self._se, True, p
                    else:
                        return self._se, False, p
                else:
                    tree = self._se._movepoint_helper(self._centre, bot, point, direction, steps)
                    if tree:
                        return tree

    # def names_in_range(self, point: Tuple[int, int], direction: str,
    #                    distance: int) -> List[str]:
    #     """ Return a list of names of players whose location is in the <direction>
    #     relative to <point> and whose location is within <distance> along both the x and y axis.
    #
    #     For example: names_in_range((100, 100), 'SE', 10) should return the names of all
    #     the players south east of (100, 100) and within 10 steps in either direction.
    #     In other words, find all players whose location is in the box with corners at:
    #     (100, 100) (110, 100) (100, 110) (110, 110)
    #
    #     Runtime: faster than O(n) when distance is small
    #
    #     === precondition ===
    #     direction in ['NE', 'SE', 'NE', 'SW']
    #     """
        # get coordinates
        # sc = (point, point)
        # if direction == 'NW':
        #     sc = ((point[0] - distance, point[1] - distance), point)
        # elif direction == 'NE':
        #     sc = ((point[0], point[1] - distance), (point[0] + distance, point[1]))
        # elif direction == 'SW':
        #     sc = ((point[0] - distance, point[1]), (point[0], point[1] + distance))
        # elif direction == 'SE':
        #     sc = (point, (point[0] + distance, point[1] + distance))
        #
        # if self.is_leaf() and self._name is not None:
        #     if sc[0][0] <= self._point[0] <= sc[1][0] and sc[0][1] <= self._point[1] <= sc[1][1]:
        #         return [self._name]
        #     else:
        #         return []
        # else:
        #     names = []
        #     if self._nw is not None:
        #         names.extend(self._nw.names_in_range(point, direction,
        #                                              distance))
        #     if self._ne is not None:
        #         names.extend(self._ne.names_in_range(point, direction,
        #                                              distance))
        #     if self._sw is not None:
        #         names.extend(self._sw.names_in_range(point, direction,
        #                                              distance))
        #     if self._se is not None:
        #         names.extend(self._se.names_in_range(point, direction,
        #                                              distance))
        #     return names

    def names_in_range(self, point: Tuple[int, int], direction: str,
                       distance: int) -> List[str]:
        """ Return a list of names of players whose location is in the <direction>
        relative to <point> and whose location is within <distance> along both the x and y axis.

        For example: names_in_range((100, 100), 'SE', 10) should return the names of all
        the players south east of (100, 100) and within 10 steps in either direction.
        In other words, find all players whose location is in the box with corners at:
        (100, 100) (110, 100) (100, 110) (110, 110)

        Runtime: faster than O(n) when distance is small

        === precondition ===
        direction in ['NE', 'SE', 'NE', 'SW']

        >>> p = QuadTree((100, 100))
        >>> p._ne = QuadTree((150, 50))
        >>> p._ne._point = (125, 75)
        >>> p._ne._name = "Anjali"
        >>> p.names_in_range((100, 100), 'NE', 50)
        ['Anjali']
        >>> s = QuadTree((100, 100))
        >>> s._ne = QuadTree((150, 50))
        >>> s._ne._point = (110, 90)
        >>> s._ne._name = "p1"
        >>> s._nw = QuadTree((50, 50))
        >>> s._nw._point = (50, 50)
        >>> s._nw._name = 'p3'
        >>> s.names_in_range((110, 90), 'NE', 30)
        ['p1']
        >>> m = QuadTree((100, 100))
        >>> m._ne = QuadTree((150, 50))
        >>> m._ne._point = (99, 99)
        >>> m._ne._name = "p1"
        >>> m._nw = QuadTree((50, 50))
        >>> m._nw._point = (50, 50)
        >>> m._nw._name = 'p3'
        >>> m.names_in_range((0, 100), 'NE', 100)
        ['p1', 'p3']
        """
        if self.is_empty():
            return []
        if self.is_leaf():
            new = []
            new_x, new_y = self._make_range(point, direction, distance)
            lower_x = min(point[0], new_x)
            upper_x = max(point[0], new_x)
            lower_y = min(point[1], new_y)
            upper_y = max((point[1], new_y))

            # if direction == 'NE':
            #     if (point[0] <= self._point[0] <= new_x) and \
            #             (new_y <= self._point[1] <= point[1]):
            #         new.append(self._name)
            # if direction == "NW":
            #     if new_x <= self._point[0] <= point[0] and \
            #             (new_y <= self._point[1] <= point[1]):
            #         new.append(self._name)
            # if direction == 'SW':
            #     if new_x <= self._point[0] <= point[0] and \
            #             (point[1] <= self._point[1] <= new_y):
            #         new.append(self._name)
            # if direction == 'SE':
            #     if point[0] <= self._point[0] <= new_x and \
            #             (point[1] <= self._point[1] <= new_y):
            #         new.append(self._name)
            if lower_x <= self._point[0] <= upper_x and lower_y <= \
                    self._point[1] <= upper_y:
                new.append(self._name)
            return new
        else:
            new = []

            new_x, new_y = self._make_range(point, direction, distance)
            lower_x = min(point[0], new_x)
            upper_x = max(point[0], new_x)
            lower_y = min(point[1], new_y)
            upper_y = max((point[1], new_y))

            if self._ne is not None and self._centre[
                0] <= upper_x and lower_y <= self._centre[1]:
                new.extend(
                    self._ne.names_in_range(point, direction, distance))
            if self._nw is not None and lower_x <= self._centre[
                0] and lower_y <= self._centre[1]:
                new.extend(
                    self._nw.names_in_range(point, direction, distance))
            if self._sw is not None and lower_x < self._centre[
                0] and upper_y > self._centre[1]:
                new.extend(
                    self._sw.names_in_range(point, direction, distance))
            if self._se is not None and upper_x > self._centre[
                0] and upper_y > self._centre[1]:
                new.extend(
                    self._se.names_in_range(point, direction, distance))
            return new

    def _make_range(self, point, direction, distance):

        if direction == 'NE':
            new_y = point[1] - distance
            new_x = point[0] + distance
        elif direction == "NW":
            new_y = point[1] - distance
            new_x = point[0] - distance
        elif direction == 'SW':
            new_y = point[1] + distance
            new_x = point[0] - distance
        else:
            new_y = point[1] + distance
            new_x = point[0] + distance

        return new_x, new_y

    def size(self) -> int:
        """ Return the number of nodes in <self>

        Runtime: O(n)
        """
        # raise NotImplementedError
        if self.is_empty():
            return 0 # return 1 or 0
        else:
            count = 1
            if self._nw is not None:
                count += self._nw.size()
            if self._ne is not None:
                count += self._ne.size()
            if self._sw is not None:
                count += self._sw.size()
            if self._se is not None:
                count += self._se.size()
        return count

    def height(self) -> int:
        """ Return the height of <self>

        Runtime: O(n)
        """
        if self.is_empty():
            return 1
        elif self.is_leaf():
            return 1
        else:
            hght = []
            if self._nw is not None:
                hght.append(self._nw.height())
            if self._ne is not None:
                hght.append(self._ne.height())
            if self._sw is not None:
                hght.append(self._sw.height())
            if self._se is not None:
                hght.append(self._se.height())
        return 1 + max(hght)


    def depth(self, tree: Tree) -> Optional[int]:
        """ Return the depth of the subtree <tree> relative to <self>.
        Return None if <tree> is not a descendant of <self>

        Runtime: O(log(n))
        """
        if self.is_empty():
            return None
        if self is tree:
            return None
        else:
            return self._get_depth(tree)

    def _get_depth(self, tree: Tree) -> Optional[int]:
        """ helper function for depth"""
        if self is tree:
            return 0
        elif tree._point[0] <= self._centre[0] and tree._point[1] <= self._centre[1]:
            if self._nw is None:
                return None
            return 1 + self._nw._get_depth(tree)
        elif tree._point[0] <= self._centre[0]:
            if self._sw is None:
                return None
            return 1 + self._sw._get_depth(tree)
        elif tree._point[0] >= self._centre[0] and tree._point[1] <= self._centre[1]:
            if self._ne is None:
                return None
            return 1 + self._ne._get_depth(tree)
        elif tree._point[0] >= self._centre[0]:
            if self._se is None:
                return None
            return 1 + self._se._get_depth(tree)


    def is_leaf(self) -> bool:
        """ Return True if <self> has no children

        Runtime: O(1)
        """
        return self._nw is None and self._ne is None and self._sw is None \
               and self._se is None

    def is_empty(self) -> bool:
        """ Return True if <self> does not store any information about the location
        of any players.

        Runtime: O(1)
        """
        return self.is_leaf() and self._name is None


class TwoDTree(Tree):
    _name: Optional[str]
    _point: Optional[Tuple[int, int]]
    _nw: Optional[Tuple[int, int]]
    _se: Optional[Tuple[int, int]]
    _lt: Optional[TwoDTree]
    _gt: Optional[TwoDTree]
    _split_type: str

    def __init__(self, nw: Tuple[int, int]=None, se: Tuple[int, int]=None):
        """Initialize a new Tree instance

        Runtime: O(1)
        """
        self._nw = nw
        self._se = se
        self._name = None
        self._point = None
        self._lt = None
        self._gt = None
        self._split_type = 'x'

    def __contains__(self, name: str) -> bool:
        """ Return True if a player named <name> is stored in this tree.

        Runtime: O(n)
        """
        if self._name is None and self._point is None:
            return False
        if self.is_leaf():
            if self._name == name:
                return True
        else:
            if self._name == name:
                return True
            if self._gt is not None:
                if name in self._gt:
                    return True
            if self._lt is not None:
                if name in self._lt:
                    return True
            return False

    def contains_point(self, point: Tuple[int, int]) -> bool:
        """ Return True if a player at location <point> is stored in this tree.

        Runtime: O(log(n))
        """
        if self.is_empty():
            return False
        if self.is_leaf():
            if self._point == point:
                return True
        else:
            if self._point == point:
                return True
            elif self._split_type == 'x':
                if point[0] <= self._point[0]:
                    if self._lt is None:
                        return False
                    if self._lt.contains_point(point):
                        return True
                else:
                    if self._gt is None:
                        return False
                    if self._gt.contains_point(point):

                        return True

            elif self._split_type == 'y':
                if point[1] <= self._point[1]:
                    if self._lt is None:
                        return False
                    if self._lt.contains_point(point):
                        return True
                else:
                    if self._gt is None:
                        return False
                    if self._gt.contains_point(point):
                        return True
            return False

    def insert(self, name: str, point: Tuple[int, int]) -> None:
        """Insert a player named <name> into this tree at point <point>.

        Raise an OutOfBoundsError if <point> is out of bounds.

        Runtime: O(log(n))
        """
        if self.is_empty():
            self._name = name
            self._point = point
            return None
        if self._split_type == 'x':
            if point[0] <= self._point[0]:
                if self._lt is None:
                    self._lt = TwoDTree()
                    self._lt._name = name
                    self._lt._point = point
                    self._split_type = 'y'
                else:
                    self._lt.insert(name, point)
            else:
                if self._gt is None:
                    self._gt = TwoDTree()
                    self._gt._name = name
                    self._gt._point = point
                    self._split_type = 'y'
                else:
                    self._gt.insert(name, point)
        else:
            if point[1] <= self._point[1]:
                if self._lt is None:
                    self._lt = TwoDTree()
                    self._lt._name = name
                    self._lt._point = point
                    self._split_type = 'x'
                else:
                    self._lt.insert(name, point)
            else:
                if self._gt is None:
                    self._gt = TwoDTree()
                    self._gt._name = name
                    self._gt._point = point
                    self._split_type = 'x'
                else:
                    self._gt.insert(name, point)

    def remove(self, name: str) -> None:
        """ Remove information about a player named <name> from this tree.

        Runtime: O(n)
        """
        tree = self._find_tree_byname(name)
        if tree is not None:
            self.remove_point(tree._point)

    def _get_xpoints_dict(self, type, size):
        if size == 'min':
            d = {self: self._point[0]}
            if self._lt is not None and self._split_type == type:
                d.update(self._lt._get_xpoints_dict(type, size))
            elif self._split_type != type:
                if self._lt is not None:
                    d.update(self._lt._get_xpoints_dict(type, size))
                if self._gt is not None:
                    d.update(self._gt._get_xpoints_dict(type, size))
            return d
        elif size == 'max':
            d = {self: self._point[0]}
            if self._gt is not None and self._split_type == type:
                d.update(self._gt._get_xpoints_dict(type, size))
            elif self._split_type != type:
                if self._lt is not None:
                    d.update(self._lt._get_xpoints_dict(type, size))
                if self._gt is not None:
                    d.update(self._gt._get_xpoints_dict(type, size))
            return d

    def _get_ypoint_dict(self, type, size):
        if size == 'min':
            d = {self: self._point[1]}
            if self._lt is not None and self._split_type == type:
                d.update(self._lt._get_xpoints_dict(type, size))
            elif self._split_type != type:
                if self._lt is not None:
                    d.update(self._lt._get_xpoints_dict(type, size))
                if self._gt is not None:
                    d.update(self._gt._get_xpoints_dict(type, size))
            return d
        elif size == 'max':
            d = {self: self._point[1]}
            if self._gt is not None and self._split_type == type:
                d.update(self._gt._get_xpoints_dict(type, size))
            elif self._split_type != type:
                if self._lt is not None:
                    d.update(self._lt._get_xpoints_dict(type, size))
                if self._gt is not None:
                    d.update(self._gt._get_xpoints_dict(type, size))
            return d

    # def _get_promoting_tree(self, size):
    #     if self._gt is not None:
    #         if self._split_type == 'x':
    #             d = self._gt._get_xpoints_dict('x', size)
    #             if size == 'max':
    #                 return max(d, key=d.get)
    #             elif size == 'min':
    #                 return min(d, key=d.get)
    #         elif self._split_type == 'y':
    #             d = self._gt._get_ypoint_dict('y', size)
    #             if size == 'max':
    #                 return max(d, key=d.get)
    #             elif size == 'min':
    #                 return min(d, key=d.get)
    #     elif self._lt is not None:
    #         if self._split_type == 'x':
    #             d = self._lt._get_xpoints_dict('x', size)
    #             if size == 'max':
    #                 return max(d, key=d.get)
    #             elif size == 'min':
    #                 return min(d, key=d.get)
    #         elif self._split_type == 'y':
    #             d = self._lt._get_ypoint_dict('y', size)
    #             if size == 'max':
    #                 return max(d, key=d.get)
    #             elif size == 'min':
    #                 return min(d, key=d.get)

    def _get_promoting_tree(self, size):
        if self._lt is not None:
            if self._split_type == 'x':
                d = self._lt._get_xpoints_dict('x', size)
            else:
                d = self._lt._get_ypoint_dict('y', size)
            if size == 'max':
                return max(d, key=d.get)
            elif size == 'min':
                return min(d, key=d.get)
        elif self._gt is not None:
            if self._split_type == 'x':
                d = self._gt._get_xpoints_dict('x', size)
            else:
                d = self._gt._get_ypoint_dict('y', size)
            if size == 'max':
                return max(d, key=d.get)
            elif size == 'min':
                return min(d, key=d.get)

    def _find_tree_byname(self, name) -> Optional[TwoDTree]:
        if self.is_empty():
            return None
        if self.is_leaf() and self._name == name:
            return self
        else:
            if self._name == name:
                return self
            if self._lt is not None:
                tree = self._lt._find_tree_byname(name)
                if tree:
                    return tree
            if self._gt is not None:
                tree = self._gt._find_tree_byname(name)
                if tree:
                    return tree

    def remove_point(self, point: Tuple[int, int]) -> None:
        """ Remove information about a player at point <point> from this tree.

        Runtime: O(log(n))
        """
        if self.is_empty():
            return None
        if not self.contains_point(point):
            return None
        if self._point == point:
            if self.is_leaf():
                self._name, self._point = None, None
            else:
                if self._lt is not None:
                    promote = self._get_promoting_tree('max')
                    hold_name, hold_point, hold_split = promote._name, promote._point, promote._split_type
                    self.remove_point(promote._point)
                    self._name, self._point = hold_name, hold_point
                    self._split_type = hold_split
                else:
                    promote = self._get_promoting_tree('max')
                    hold_name, hold_point, hold_split = promote._name, promote._point, promote._split_type
                    self._lt, self._gt = self._gt, None
                    self.remove_point(promote._point)
                    self._name, self._point = hold_name, hold_point
                    self._split_type = hold_split
        else:
            tree = self._get_tree_bypoint(point)
            if tree[0].is_leaf():
                if tree[1]._gt is tree[0]:
                    tree[1]._gt = None
                elif tree[1]._lt is tree[0]:
                    tree[1]._lt = None
            else:
                if tree[0]._gt is not None:
                    promote = tree[0]._get_promoting_tree('min')
                else:
                    promote = tree[0]._get_promoting_tree('max')
                hold_name, hold_point = promote._name, promote._point
                self.remove_point(promote._point)
                tree[0]._name, tree[0]._point = hold_name, hold_point
                tree[0]._split_type = promote._split_type

    def _get_tree_bypoint(self, point) -> Tuple[TwoDTree, TwoDTree]:
        if self._split_type == 'x':
            if point[0] <= self._point[0]:
                if self._lt._point == point:
                    return self._lt, self
                else:
                    t = self._lt._get_tree_bypoint(point)
                    if t:
                        return t
            elif point[0] > self._point[0]:
                if self._gt._point == point:
                    return self._gt, self
                else:
                    p = self._gt._get_tree_bypoint(point)
                    if p:
                        return p
        elif self._split_type == 'y':
            if point[1] <= self._point[1]:
                if self._lt._point == point:
                    return self._lt, self
                else:
                    t = self._lt._get_tree_bypoint(point)
                    if t:
                        return t
            elif point[1] > self._point[1]:
                if self._gt._point == point:
                    return self._gt, self
                else:
                    p = self._gt._get_tree_bypoint(point)
                    if p:
                        return p

    def move(self, name: str, direction: str, steps: int) -> Optional[
        Tuple[int, int]]:
        """ Return the new location of the player named <name> after moving it
        in the given <direction> by <steps> steps.

        Raise an OutOfBoundsError if this would move the player named
        <name> out of bounds (before moving the player).

        Runtime: O(n)

        === precondition ===
        direction in ['N', 'S', 'E', 'W']
        """
        tree = self._find_tree_byname(name)
        if tree:
            return self.move_point(tree._point, direction, steps)

    def move_point(self, point: Tuple[int, int], direction: str, steps: int) ->\
            Optional[Tuple[int, int]]:
        """ Return the new location of the player at point <point> after moving it
        in the given <direction> by <steps> steps.

        Raise an OutOfBoundsError if this would move the player at point
        <point> out of bounds (before moving the player).

        Moving a point may require the tree to be reorganized. This method should do
        the minimum amount of tree reorganization possible to move the given point properly.

        Runtime: O(log(n))

        === precondition ===
        direction in ['N', 'S', 'E', 'W']

        """
        if not self.contains_point(point):
            return None
        if self._point == point:
            new_coords = self._change_coordinates(direction, steps)
            if new_coords[0] <= self._se[0] and new_coords[1] <= self._se[1]:
                self.remove_point(self._point)
                self.insert(self._name, new_coords)
            else:
                raise OutOfBoundsError
        else:
            tree = self._get_tree_bypoint(point)
            new_coords = tree[0]._change_coordinates(direction, steps)
            if new_coords[0] <= self._se[0] and new_coords[1] <= self._se[1]:
                self.remove_point(tree[0]._point)
                self.insert(tree[0]._name, new_coords)
                return new_coords
            else:
                raise OutOfBoundsError

    def _change_coordinates(self, direction, steps) -> Tuple[int, int]:
        x_coord = self._point[0]
        y_coord = self._point[1]
        if direction == 'N':
            y_coord = y_coord - steps
        elif direction == 'E':
            x_coord = x_coord + steps
        elif direction == 'S':
            y_coord = y_coord + steps
        elif direction == 'W':
            x_coord = x_coord - steps

        return x_coord, y_coord

    def names_in_range(self, point: Tuple[int, int], direction: str,
                       distance: int) -> List[str]:
        """ Return a list of names of players whose location is in the <direction>
        relative to <point> and whose location is within <distance> along both the x and y axis.

        For example: names_in_range((100, 100), 'SE', 10) should return the names of all
        the players south east of (100, 100) and within 10 steps in either direction.
        In other words, find all players whose location is in the box with corners at:
        (100, 100) (110, 100) (100, 110) (110, 110)

        Runtime: faster than O(n) when distance is small

        === precondition ===
        direction in ['NE', 'SE', 'NE', 'SW']
        """
        sc = (point, point)
        if direction == 'NW':
            sc = ((point[0] - distance, point[1] - distance), point)
        elif direction == 'NE':
            sc = (
            (point[0], point[1] - distance), (point[0] + distance, point[1]))
        elif direction == 'SW':
            sc = (
            (point[0] - distance, point[1]), (point[0], point[1] + distance))
        elif direction == 'SE':
            sc = (point, (point[0] + distance, point[1] + distance))

        if self.is_leaf() and self._name is not None:
            if sc[0][0] <= self._point[0] <= sc[1][0] and sc[0][1] <= self._point[1] <= sc[1][1]:
                return [self._name]
            else:
                return []
        else:
            names = []
            if sc[0][0] <= self._point[0] <= sc[1][0] and sc[0][1] <= self._point[1] <= sc[1][1]:
                names.append(self._name)
            if self._lt is not None:
                names.extend(self._lt.names_in_range(point,
                                                     direction, distance))
            if self._gt is not None:
                names.extend(self._gt.names_in_range(point,
                                                     direction, distance))
            return names



    def size(self) -> int:
        """ Return the number of nodes in <self>

        Runtime: O(n)
        """
        if self.is_empty():
            return 0
        if self.is_leaf():
            return 1
        else:
            count = 1
            if self._lt is not None:
                count += self._lt.size()
            if self._gt is not None:
                count += self._gt.size()
            return count

    def height(self) -> int:
        """ Return the height of <self>

        Runtime: O(n)
        """
        if self.is_empty():
            return 0
        if self.is_leaf():
            return 1
        else:
            hght = []
            if self._lt is not None:
                hght.append(self._lt.height())
            if self._gt is not None:
                hght.append(self._gt.height())
            return 1 + max(hght, default=0)

    def depth(self, tree: Tree) -> Optional[int]:
        """ Return the depth of the subtree <tree> relative to <self>.
        Return None if <tree> is not a descendant of <self>

        Runtime: O(log(n))
        """
        if self.is_empty():
            return None
        if self is tree:
            return None
        return self._get_depth(tree)


    def _get_depth(self, tree):
        if self.is_leaf():
            if self is tree:
                return 0
        else:
            if self._split_type == 'x':
                if tree._point[0] <= self._point[0]:
                    if self._lt is not None:
                        return 1 + self._lt._get_depth(tree)
                else:
                    if self._gt is not None:
                        return 1 + self._gt._get_depth(tree)
            elif self._split_type == 'y':
                if tree._point[1] <= self._point[1]:
                    if self._gt is not None:
                        return 1 + self._lt._get_depth(tree)
                else:
                    if self._gt is not None:
                        return 1 + self._gt._get_depth(tree)


    def is_leaf(self) -> bool:
        """ Return True if <self> has no children

        Runtime: O(1)
        """
        return self._lt is None and self._gt is None

    def is_empty(self) -> bool:
        """ Return True if <self> does not store any information about the location
        of any players.

        Runtime: O(1)
        """
        return self.is_leaf() and self._name is None

    def balance(self) -> None:
        """ Balance <self> so that there is at most a difference of 1 between
        the size of the _lt subtree and the size of the _gt subtree for all
        trees in <self>.
        """
        instance_list = self._all_instances()
        for thing in instance_list:
            thing._lt, thing._gt = None, None
        new_tree = self._balance_tree(instance_list, 0)
        if new_tree is not None:
            self._point, self._name = new_tree._point, new_tree._name
            self._lt = new_tree._lt
            self._gt = new_tree._gt
            self._gt = self._gt

    def _all_instances(self) -> List[TwoDTree]:
        if self.is_empty():
            return []
        elif self.is_leaf():
            return [self]
        else:
            instances = [self]
            if self._lt is not None:
                instances.extend(self._lt._all_instances())
            if self._gt is not None:
                instances.extend(self._gt._all_instances())
            return instances

    def _balance_tree(self, lst: List[TwoDTree], split_num: int) -> \
            Optional[TwoDTree]:
        if len(lst) == 0:
            return None
        elif len(lst) == 1:
            return lst[0]
        else:
            if split_num % 2 == 0:
                sorted_lst = self._sort_x(lst)
            else:
                sorted_lst = self._sort_y(lst)

            mid = (len(sorted_lst) - 1) // 2
            # if split_num % 2 == 0:
            #     while mid + 1 <= len(sorted_lst) and \
            #             sorted_lst[mid]._point[0] == \
            #             sorted_lst[mid + 1]._point[0]:
            #         mid += 1
            # else:
            #     while mid + 1 <= len(sorted_lst) and \
            #             sorted_lst[mid]._point[1] == \
            #             sorted_lst[mid + 1]._point[1]:
            #         mid += 1
            root = sorted_lst[mid]
            if root is not None:
                if split_num % 2 == 0:
                    root._split_type = 'x'
                else:
                    root._split_type = 'y'
            root._lt = self._balance_tree(sorted_lst[:mid], split_num + 1)
            if root._lt is not None:
                if split_num % 2 == 0:
                    root._lt._split_type = 'y'
                else:
                    root._lt._split_type = 'x'
            root._gt = self._balance_tree(sorted_lst[mid+1:], split_num + 1)
            if root._gt is not None:
                if split_num % 2 == 0:
                    root._gt._split_type = 'y'
                else:
                    root._gt._split_type = 'x'

            return root

    def _sort_x(self, lst: List[TwoDTree]):
        l1 = []
        for node in lst:
            l1.append(node._point[0])
        l1.sort()
        l2 = []
        for x in l1:
            for node in lst:
                if node._point[0] == x and node not in l2:
                    l2.append(node)
        return l2

    def _sort_y(self, lst: List[TwoDTree]):
        l1 = []
        for node in lst:
            l1.append(node._point[1])
        l1.sort()
        l2 = []
        for y in l1:
            for node in lst:
                if node._point[1] == y and node not in l2:
                    l2.append(node)
        return l2

